# JACDAC: Joint Asynchronous Communications, Device Agnostic Control.

## What is JACDAC?

JACDAC is a single wire serial protocol for the plug and play of accessories for embedded computers.

## Why do we need _another_ protocol?

Conventionally SPI and I2C are used to communicate with other devices over a wire. I2C and SPI principally work in Central/Peripheral (used in place of outdated Master/Slave terminology) mode: One central directs the operation of all peripherals, configuring and interrogating them as desired.

I2C uses static addresses for all components i.e. all MMA8653 accelerometers will have the same address. Each I2C component specifies its own register map and registers can be directly accessed by combining the component's address and register offset. I2C requires two wires to operate: _SCL_ to synchronise the communication speed, and _SDA_ for data payloads.

Instead of static addressing, SPI uses the peripheral select wire to indicate the peripheral to be accessed. SPI components require register offsets to be communicated over the MOSI (Central out peripheral in) line, and the selected peripheral responds using the MISO (Central in peripheral out) line. Multi-central modes for SPI and I2C are not well-supported.

However, in the world of the Internet of Things (IoT), peer-to-peer scenarios are common place: programmers often want to share data with other devices in the vicinity. But what solution is available for sharing data locally through wired communications? I2C or SPI cannot be used because of their addressing approaches and communication topology (single Central only)––if two devices with the same components join buses, how are addresses resolved? One could develop a custom UART based protocol, or add ethernet capabilities to a device and run IPv4, but each of these approaches have obvious drawbacks.

Built on UART, JACDAC requires _no additional hardware to operate_ as UART is supported in hardware by all modern processors. Peer to peer scenarios are enabled through a _broadcast topology_ where every device is a Central. Communications speeds are fixed to 1 mBaud, which means only _a single data wire_ is required.

## A UART based solution

For reliable communications, embedded programmers tend to stay clear of UART: there is no common clock, the baud rate must be pre-determined, and there is no bus arbitration. Fortunately, hardware has improved over time adding DMA buffering and auto-baud detection thus improving reliability. To sidestep the issue of determining the baudrate, JACDAC is fixed to 1 mBaud; the problem of bus arbitration still remains.

UART hardware modules traditionally occupy two IO lines, one for transmission the other for reception; when idle, IO lines float high such that they read a logical one. This behaviour remains the same in JACDAC, the bus floats high when no devices are transmitting. Bus arbitration is achieved through the transmitting device driving the line low for 10 microseconds, beginning transmission 150 microseconds later. This approach allows devices to listen to the bus in a low power mode using a GPIO interrupt, and power up and configure the UART hardware only when required.

A 10 microsecond window is used for two reasons: (1) the probability of a transmission collision is reduced; and (2) to simplify error logic---a low period of 30 microseconds or more is enough time for  UART hardware to be operable and a break condition to be generated. It is then challenging to differentiate between a true UART error, and an error generated by the low period.

![picture of a low period followed by data](images/physical.svg)

The process described is visualised in the image above. The bus is high for a period of time, driven low for 10 microseconds, data following 150 microseconds later.

## A broadcast paradigm

![image of devices in a broadcast formation](images/bus.svg)

The image above shows JACDAC devices in a broadcast formation. Each device has a simple stack featuring: (1) a physical layer handling the transmission and reception of packets; (2) a logic layer which performs the routing of packets; to (3) device drivers running on the device.

Since the physical layer has been discussed previously, we move onto the logic layer

### The Logic Layer

A JACDAC packet is simple, consisting of: a _crc_ (cyclic redundancy check) to provide guarantees of packet consistency; an _address_ indicating the source _or_ destination address of a driver; the _size_ of the data field; and finally the _data_ payload specified by a driver.

```cpp
struct JDPkt
{
    uint16_t crc;
    uint8_t address;
    uint8_t size;
    uint8_t data[32];
}
```

#### Routing a packet

With the limited information in the packet above, how do packets get routed to their destination?

So to not to fill all packets with unnecessary metadata, JACDAC devices broadcast driver information every 500 milliseconds. All devices receive this information providing a mapping from a small 8-bit address to a fully enumerated driver. Conveniently, this also allows the detection of the addition or removal of drivers from the bus.

Driver information is shared using a special packet type called a `ControlPacket`, which is embedded inside a standard JACDAC packet. A `ControlPacket` contains: a _packet_type_, used to differentiate between types of control packet; an _address_, which should be the same address that is used in a standard packet; any _flags_ specified by the driver (the upper eight bits of which are reserved for the logic layer); a _driver_class_ used to indicate the type of driver it is (i.e. a Joystick); a _serial_number_ that uniquely identifies a driver; and finally any additional payload information specified by the driver.

```cpp
struct ControlPacket
{
    uint8_t packet_type;
    uint8_t address;
    uint16_t flags;
    uint32_t driver_class;
    uint32_t serial_number;
    uint8_t data[20];
};
```

#### Virtual Mode

![image of drivers in a virtual mode](images/virtual.svg)

#### Paired Mode

![image of drivers in a paired mode](images/paired.svg)

#### Broadcast Mode

![image of drivers in a broadcast mode](images/broadcast.svg)