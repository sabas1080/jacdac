# JACDAC: Joint Asynchronous Communications, Device Agnostic Control.

## What is JACDAC?

JACDAC is a single wire serial protocol for the plug and play of accessories for embedded computers.

## Why do we need _another_ protocol?

Conventionally SPI and I2C are used to communicate with other devices over a wire. I2C and SPI principally work in Central/Peripheral (used in place of outdated Master/Slave terminology) mode: One central directs the operation of all peripherals, configuring and interrogating them as desired.

I2C uses static addresses for all components i.e. all MMA8653 accelerometers will have the same address. Each I2C component specifies its own register map and registers can be directly accessed by combining the component's address and register offset. I2C requires two wires to operate: _SCL_ to synchronise the communication speed, and _SDA_ for data payloads.

Instead of static addressing, SPI uses the peripheral select wire to indicate the peripheral to be accessed. SPI components require register offsets to be communicated over the MOSI (Central out peripheral in) line, and the selected peripheral responds using the MISO (Central in peripheral out) line. Multi-central modes for SPI and I2C are not well-supported.

However, in the world of the Internet of Things (IoT), peer-to-peer scenarios are common place: programmers often want to share data with other devices in the vicinity. But what solution is available for sharing data locally through wired communications? I2C or SPI cannot be used because of their addressing approaches and communication topology (single Central only)––if two devices with the same components join buses, how are addresses resolved? One could develop a custom UART based protocol, or add ethernet capabilities to a device and run IPv4, but each of these approaches have obvious drawbacks.

Built on UART, JACDAC requires _no additional hardware to operate_ as UART is supported in hardware by all modern processors. Peer to peer scenarios are enabled through a _broadcast topology_ where every device is a Central. Communications speeds are fixed to 1 mBaud, which means only _a single data wire_ is required.

## A UART based solution

For reliable communications, embedded programmers tend to stay clear of UART: there is no common clock, the baud rate must be pre-determined, and there is no bus arbitration. Fortunately, hardware has improved over time adding DMA buffering and auto-baud detection thus improving reliability. To sidestep the issue of determining the baudrate, JACDAC is fixed to 1 mBaud; the problem of bus arbitration still remains.

UART hardware modules traditionally occupy two IO lines, one for transmission the other for reception; when idle, IO lines float high such that they read a logical one. This behaviour remains the same in JACDAC, the bus floats high when no devices are transmitting. Bus arbitration is achieved through the transmitting device driving the line low for 10 microseconds, beginning transmission 150 microseconds later. This approach allows devices to listen to the bus in a low power mode using a GPIO interrupt, and power up and configure the UART hardware only when required.

A 10 microsecond window is used for two reasons: (1) the probability of a transmission collision is reduced; and (2) a low period of 30 microseconds or more is enough time for the UART hardware to be operable and a break condition to be generated making it hard to differentiate between a true UART error, and an error generated by the low period.

![picture of a low period followed by data](images/physical.svg)

The process decribed is visualised in the image above. The bus is high for a period of time, driven low for 10 microseconds, data following 150 microseconds later.

## A broadcast paradigm

![image of devices in a broadcast formation](images/bus.svg)